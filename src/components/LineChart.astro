---
interface DataPoint {
  value: number;
  label: string;
  color?: string;
}

interface Props {
  data: DataPoint[];
  width?: number;
  height?: number;
  padding?: number;
}

const { data, width = 800, height = 400, padding = 0 } = Astro.props;

// Calcular dimensiones del área de gráfico
const chartWidth = width - padding * 2;
const chartHeight = height - padding * 2;

// Encontrar valores mínimos y máximos para escalar
const values = data.map((d) => d.value);
const maxValue = Math.max(...values);
const minValue = Math.min(...values);
const valueRange = maxValue - minValue;

// Función para escalar valores al tamaño del gráfico
const scaleY = (value: number) => {
  return (
    chartHeight - ((value - minValue) / valueRange) * chartHeight + padding
  );
};

const scaleX = (index: number) => {
  return (index / (data.length - 1)) * chartWidth + padding;
};

// Generar path data para la línea principal
const linePath = data
  .map((point, index) => {
    const x = scaleX(index);
    const y = scaleY(point.value);
    return index === 0 ? `M ${x} ${y}` : `L ${x} ${y}`;
  })
  .join(" ");

// Generar path data para el área bajo la línea
const areaPath = `${linePath} L ${scaleX(data.length - 1)} ${height - padding} L ${padding} ${height - padding} Z`;
---

<div class="relative">
  <svg
    width="100%"
    height={height}
    viewBox={`0 0 ${width} ${height}`}
    class="overflow-visible"
  >
    <!-- Líneas de cuadrícula horizontales -->
    {
      Array.from({ length: 5 }, (_, i) => {
        const y = padding + i * (chartHeight / 4);
        const value = maxValue - i * (valueRange / 4);
        return (
          <g>
            <line
              x1={padding}
              y1={y}
              x2={width - padding}
              y2={y}
              stroke="#334155"
              stroke-width="1"
              stroke-dasharray="4 4"
            />
            <text
              x={padding + 20}
              y={y}
              text-anchor="end"
              alignment-baseline="middle"
              class="fill-gray-400 text-[10px] select-none"
            >
              ${value.toLocaleString()}
            </text>
          </g>
        );
      })
    }

    <!-- Líneas de cuadrícula verticales y etiquetas -->
    {
      data.map((point, index) => {
        const x = scaleX(index);
        return (
          <g>
            <line
              x1={x}
              y1={padding}
              x2={x}
              y2={height - padding}
              stroke="#334155"
              stroke-width="1"
              stroke-dasharray="4 4"
            />
            <text
              x={x}
              y={height + 18}
              text-anchor="middle"
              class="fill-gray-400 text-sm capitalize select-none"
            >
              {point.label}
            </text>
          </g>
        );
      })
    }

    <!-- Área bajo la línea -->
    <path d={areaPath} fill="url(#gradient)" opacity="0.1"></path>

    <!-- Línea principal -->
    <path
      d={linePath}
      fill="none"
      stroke="#A5B4FC"
      stroke-width="3"
      stroke-linecap="round"
      stroke-linejoin="round"
      class="transition-all duration-300 ease-in-out"></path>

    <!-- Puntos de datos -->
    {
      data.map((point, index) => (
        <g>
          <circle
            cx={scaleX(index)}
            cy={scaleY(point.value)}
            r="6"
            class="peer fill-navy-800 stroke-[#A5B4FC] stroke-[3]"
          />
          <circle
            cx={scaleX(index)}
            cy={scaleY(point.value)}
            r="12"
            class="peer fill-[#A5B4FC] opacity-10"
          />
          <text
            x={scaleX(index)}
            y={scaleY(point.value) - 20}
            text-anchor="middle"
            class="fill-white text-[10px] font-medium opacity-0 select-none peer-hover:opacity-100 peer-active:opacity-100"
          >
            ${point.value.toLocaleString()}
          </text>
        </g>
      ))
    }

    <!-- Gradiente para el área bajo la línea -->
    <defs>
      <linearGradient id="gradient" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#A5B4FC" stop-opacity="0.5"></stop>
        <stop offset="100%" stop-color="#A5B4FC" stop-opacity="0"></stop>
      </linearGradient>
    </defs>
  </svg>
</div>
